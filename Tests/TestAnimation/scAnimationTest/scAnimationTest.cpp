/*
-----------------------------------------------------------------------------
Filename:    scAnimationTest.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.7.x Application Wizard for VC10 (July 2011)
      http://code.google.com/p/ogreappwizards/
-----------------------------------------------------------------------------
*/

#include "scAnimationTest.h"
#include "scTimeLine.h"
#include "scError.h"
#include "scGenericAnimation.h"

//-------------------------------------------------------------------------------------
scAnimationTest::scAnimationTest(void)
	: mTimeLineManager(0), mGui(0), mPlatform(0)
{
	mTimeLineManager = new scTimeLineManager();
}
//-------------------------------------------------------------------------------------
scAnimationTest::~scAnimationTest(void)
{
	if (mTimeLineManager)
	{
		delete mTimeLineManager;
		mTimeLineManager = 0;
	}
	if (mGui)
	{
		mGui->shutdown();
		delete mGui;
		mGui = 0;
	}
	if (mPlatform)
	{
		mPlatform->shutdown();
		delete mPlatform;
		mPlatform = 0;
	}
}

//-------------------------------------------------------------------------------------
void scAnimationTest::createScene(void)
{
    Ogre::Entity* ogreHead = mSceneMgr->createEntity("Head", "ogrehead.mesh");

    Ogre::SceneNode* headNode = mSceneMgr->getRootSceneNode()->createChildSceneNode();
    headNode->attachObject(ogreHead);
	headNode->setPosition(-250, 0, -500);

    // Set ambient light
    mSceneMgr->setAmbientLight(Ogre::ColourValue(0.5, 0.5, 0.5));

    // Create a light
    Ogre::Light* l = mSceneMgr->createLight("MainLight");
    l->setPosition(20,80,50);

	// MyGUI
	mPlatform = new MyGUI::OgrePlatform();
	mPlatform->initialise(mWindow, mSceneMgr);
	mGui = new MyGUI::Gui();
	mGui->initialise();

	MyGUI::ButtonPtr button = mGui->createWidget<MyGUI::Button>("Button", 30, 30, 80, 80, MyGUI::Align::Default, "Main");
	button->setCaption("exit");

	// 创建时间轴
	scTimeLine* tl = mTimeLineManager->createTimeLine("me", 60);
	// 创建动画
	scVector3Animation* ani = tl->createVector3Animation([headNode](const Ogre::Vector3& position){headNode->setPosition(position);}, true);
	// 创建关键帧
	ani->createKeyFrame(0, Ogre::Vector3(-250, 0, -500), scKeyFrame::IT_SQUARE_IN);
	ani->createKeyFrame(1000, Ogre::Vector3(0, 0, -500), scKeyFrame::IT_SQUARE_OUT);
	ani->createKeyFrame(2000, Ogre::Vector3(250, 0, -500), scKeyFrame::IT_SQUARE_IN);
	ani->createKeyFrame(3000, Ogre::Vector3(0, 0, -500), scKeyFrame::IT_SQUARE_OUT);
	ani->createKeyFrame(4000, Ogre::Vector3(-250, 0, -500));

	// 创建时间轴
	tl = mTimeLineManager->createTimeLine("me2", 5);
	// 创建动画
	scF32Animation* ani2 = tl->createF32Animation([headNode](f32 rad){headNode->yaw(Ogre::Radian(rad));}, true);
	// 创建关键帧
	ani2->createKeyFrame(0, 0.5f);

	tl = mTimeLineManager->getTimeLine("me");
	// TODO: 为类型之间编写包装，让它们可以自由运算
	scVector2Animation* ani3 = tl->createVector2Animation([button](Ogre::Vector2 const& pos){button->setPosition(pos);}, true);
	ani3->createKeyFrame(0, Ogre::Vector2(30, 30));
	ani3->createKeyFrame(1500, Ogre::Vector2(300, 30));
	ani3->createKeyFrame(3000, Ogre::Vector2(30, 30));
}

bool scAnimationTest::frameRenderingQueued( const Ogre::FrameEvent& evt )
{
	mTimeLineManager->run((u32)(evt.timeSinceLastFrame * 1000));
	//scTimeLine* tl = mTimeLineManager->getTimeLine("me");
	//scErrMsg(tl->getScaleFactor(), DL_TRIVIAL);
	return BaseApplication::frameRenderingQueued(evt);
}

bool scAnimationTest::keyPressed( const OIS::KeyEvent &arg )
{
	if (arg.key == OIS::KC_U)
	{
		scTimeLine* tl = mTimeLineManager->getTimeLine("me");
		tl->setScaleFactor(tl->getScaleFactor() * 2);
	}
	else if (arg.key == OIS::KC_J)
	{
		scTimeLine* tl = mTimeLineManager->getTimeLine("me");
		tl->setScaleFactor(tl->getScaleFactor() / 2);
	}
	return BaseApplication::keyPressed(arg);
}



#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

#include <iostream>
#include "scError.h"

extern "C" {

    INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
    {

#define SHOW_CONSOLE 
#ifdef SHOW_CONSOLE
		/*---------------------------------------------------------------------------------*/
		// 创建控制台窗口,并将标准输入流，标准输出流和标准错误流重定向至控制台
		FILE* fpDebugOut = NULL; 
		FILE* fpDebugIn   = NULL;
		FILE* fpDebugErr = NULL;
		if( !AllocConsole() )
			MessageBoxA(NULL, "控制台生成失败。", NULL, 0); 
		SetConsoleTitleA("Debug Window"); 
		freopen_s(&fpDebugOut, "CONOUT$","w", stdout); 
		freopen_s(&fpDebugIn, "CONIN$", "r", stdin); 
		freopen_s(&fpDebugErr, "CONOUT$","w", stderr); 
		setlocale(LC_ALL, "chs");
		std::cout << "控制台已创建！" << std::endl;
		/*---------------------------------------------------------------------------------*/
#endif

        // Create application object
        scAnimationTest app;

        try {
            app.go();
        } catch( Ogre::Exception& e ) {
            MessageBoxA( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
        }

#ifdef SHOW_CONSOLE
		/*---------------------------------------------------------------------------------*/
		// 销毁控制台窗口
		fclose(fpDebugOut); 
		fclose(fpDebugIn); 
		fclose(fpDebugErr);
		FreeConsole();
		/*---------------------------------------------------------------------------------*/
#endif

        return 0;
    }

}
